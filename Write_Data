
`include "ddr_pkg.pkg"
module Write_Ddata(ctrl_interface ctrl_intf, ddr_interface ddr_intf, tb_interface tb_intf) ; 


  wr_data_type wr_in , wr_out,wr_out_final;  
  wr_data_type wr_queue[$]; 
  logic [DATA_WIDTH-1:0] DQ_BUS ; // 8 bits data bus 
  bit dqs_t ; 
  bit dqs_c;
  
  
  
  always_comb 
  begin 
  
  
  if(!ddr_intf.reset_n)
      begin 
        wr_queue.delete(); 
      end 
      
      
      
  
  if(ctrl_intf.act_rdy || ctrl_intf.no_act_rdy )
         begin
          
          wr_in.burst_length=ctrl_intf.BL ;
           $display("burst length is %0d ",wr_in.burst_length );
          wr_in.preamable = ctrl_intf.WR_PRE;// as it's a write data 
          wr_in.wr_data = tb_intf.gen_rw_Data ; 
          // then we need to push  these data to the queue 
           wr_queue.push_back(wr_in);
          // $display("wr_in.burst_length= %b ,  wr_in.preamable= %b wr_in.wr_data= %b" , wr_in.burst_length,wr_in.preamable,wr_in.wr_data );
           
          
           
          end 
          
          
          
  if(ctrl_intf.wr_rdy)
       begin 
        //  $display("I'm here!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"); 
       wr_out_final = wr_out ; 
       // missing sth 
       
       end 
  
  
          
  end
  
  
  
   
   always_ff@(posedge ctrl_intf.wr_rdy)
    begin
       $display("I'm here!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"); 
      wr_out = wr_queue.pop_front();
    
      
    end
    
    
    
    
    always_ff @(intf.CK_t)
     begin
        if ((ctrl_intf.wr_rdy) )begin
    //$display("I'm here!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"); 
          set_differential_dqs(.rw_D(wr_out_final));
          set_write_data_pins (.rw_D(wr_out_final));
     
        end
    end
    
    
   // outputing the read data is not yet implemented 
   
    
    
    

// in case of write operation ...
  task set_write_data_pins(input wr_data_type rw_D );
     begin 
       $display("I'm here!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"); 
     @(posedge ddr_intf.CK_r); 
     DQ_BUS = 8'bz ;
     repeat(rw_D.preamable) @(posedge ddr_intf.CK_r); 
       
     repeat(rw_D.burst_length)
     begin  
       @(posedge ddr_intf.CK_r)
      DQ_BUS = rw_D.wr_data[7:0] ;
       rw_D.wr_data=  rw_D.wr_data >> 8 ;
       $display("DQ_BUS= %h",DQ_BUS); 
     end 
     DQ_BUS = 8'bz ; 
     
     end 
    
     endtask 
     
     
     
     
     // incase of read operations , Data is outputed from the memory 
  task set_read_data_pins (input wr_data_type rw_D);
      begin 
        
     @(posedge ddr_intf.CK_r); 
     DQ_BUS = 8'bz ;
     repeat(rw_D.preamable) @(posedge ddr_intf.CK_r); 
     repeat(rw_D.burst_length)
     begin  
       @(posedge ddr_intf.CK_r)
       DQ_BUS = rw_D.wr_data[7:0] ;
       rw_D.wr_data=  rw_D.wr_data >> 8 ;
       
     
     
     end 
     DQ_BUS = 8'bz ; 
     
     end 
      
     endtask 
     
     
  task set_differential_dqs(input wr_data_type rw_D );
     begin
     @(posedge ddr_intf.CK_r );
     dqs_t <=  1'b1; 
     dqs_c <=  1'b0; 
       repeat(rw_D.preamable-1)@(posedge ddr_intf.CK_r);// refer to jedec p.115
     repeat(rw_D.burst_length +1 )@(posedge ddr_intf.CK_r); // as we started one clock cycle before outputing data on the bus
     begin 
     dqs_t <= !dqs_t; 
     dqs_c <= !dqs_c;
     end 
       
       
       
     // both clocks will return to logic one after data is outputed on the dq bus 
      dqs_t <= 1'b1; 
      dqs_c <= 1'b1; 
     end 
     
     endtask 
     
     
     
  
endmodule
